<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP-AJAX-Lab: MultiTimer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP-AJAX-Lab
   &#160;<span id="projectnumber">0.99.6</span>
   </div>
   <div id="projectbrief">HTTP server, AJAX API backend, web application and Soc hardware drivers for WiFi remote control of the MCPWM hardware modules on the Espressif ESP32 SoC</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_multi_timer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultiTimer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ticker timer derivative allowing for a fixed number of repeated calls.  
 <a href="class_multi_timer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multi__timer_8hpp_source.html">multi_timer.hpp</a>&gt;</code></p>

<p>Inherits Ticker.</p>

<p>Inherited by <a class="el" href="class_multi_timer_non_static.html">MultiTimerNonStatic&lt; TClass &gt;</a>, and <a class="el" href="class_multi_timer_non_static.html">MultiTimerNonStatic&lt; AppController &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_multi_timer_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae7416e3339b9589972b860a6d0d59b48"><td class="memTemplParams" colspan="2"><a id="ae7416e3339b9589972b860a6d0d59b48"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7416e3339b9589972b860a6d0d59b48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_identity_t</b> = typename <a class="el" href="struct_multi_timer_1_1type__identity.html">type_identity</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ae7416e3339b9589972b860a6d0d59b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501b46d206d81835e659984e86ee7de4"><td class="memItemLeft" align="right" valign="top"><a id="a501b46d206d81835e659984e86ee7de4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>callback_with_arg_and_count_t</b> = void(*)(void *, uint32_t)</td></tr>
<tr class="separator:a501b46d206d81835e659984e86ee7de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab11322a4f50ffccc19cde0caf302b221"><td class="memTemplParams" colspan="2">template&lt;typename TArg &gt; </td></tr>
<tr class="memitem:ab11322a4f50ffccc19cde0caf302b221"><td class="memTemplItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_multi_timer.html#ab11322a4f50ffccc19cde0caf302b221">attach_static_ms</a> (uint32_t milliseconds, uint32_t total_repeat_count, void(*callback)(type_identity_t&lt; TArg &gt;, uint32_t), TArg arg, bool first_tick_nodelay=false)</td></tr>
<tr class="memdesc:ab11322a4f50ffccc19cde0caf302b221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a free function, static member function or a non-capturing lambda function to the timer.  <a href="class_multi_timer.html#ab11322a4f50ffccc19cde0caf302b221">More...</a><br /></td></tr>
<tr class="separator:ab11322a4f50ffccc19cde0caf302b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a525176e7ecf6b8d6b0670a38967334"><td class="memTemplParams" colspan="2"><a id="a3a525176e7ecf6b8d6b0670a38967334"></a>
template&lt;typename TArg &gt; </td></tr>
<tr class="memitem:a3a525176e7ecf6b8d6b0670a38967334"><td class="memTemplItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>attach_static_ms</b> (uint32_t milliseconds, uint32_t total_repeat_count, void(*callback)(type_identity_t&lt; TArg &gt;), TArg arg, bool first_tick_nodelay=false)</td></tr>
<tr class="separator:a3a525176e7ecf6b8d6b0670a38967334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83b81c34537dcd6a0bc94272b7c9a80"><td class="memItemLeft" align="right" valign="top"><a id="aa83b81c34537dcd6a0bc94272b7c9a80"></a>
esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><b>attach_static_ms</b> (uint32_t milliseconds, uint32_t total_repeat_count, callback_t callback, bool first_tick_nodelay=false)</td></tr>
<tr class="separator:aa83b81c34537dcd6a0bc94272b7c9a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478d115c8db9b4c1e3013ebfe525c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multi_timer.html#a2478d115c8db9b4c1e3013ebfe525c81">start</a> ()</td></tr>
<tr class="separator:a2478d115c8db9b4c1e3013ebfe525c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf08908d37a0a87a2575ff81fc9a6c6"><td class="memItemLeft" align="right" valign="top"><a id="afaf08908d37a0a87a2575ff81fc9a6c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>start</b> (uint32_t interval_ms)</td></tr>
<tr class="separator:afaf08908d37a0a87a2575ff81fc9a6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5c480ad4ff0e6b6e879d211a1bcfb"><td class="memItemLeft" align="right" valign="top"><a id="a82d5c480ad4ff0e6b6e879d211a1bcfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stop</b> ()</td></tr>
<tr class="separator:a82d5c480ad4ff0e6b6e879d211a1bcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f08b5cf37f5160ee06e50cc6a8de61"><td class="memItemLeft" align="right" valign="top"><a id="ae8f08b5cf37f5160ee06e50cc6a8de61"></a>
esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><b>stop_return_errors</b> ()</td></tr>
<tr class="separator:ae8f08b5cf37f5160ee06e50cc6a8de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b957ca288b4a9d93f3470b698af161f"><td class="memItemLeft" align="right" valign="top"><a id="a4b957ca288b4a9d93f3470b698af161f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pause</b> ()</td></tr>
<tr class="separator:a4b957ca288b4a9d93f3470b698af161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7586d547042591db7971e8686246bc"><td class="memItemLeft" align="right" valign="top"><a id="a0f7586d547042591db7971e8686246bc"></a>
esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><b>pause_return_errors</b> ()</td></tr>
<tr class="separator:a0f7586d547042591db7971e8686246bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f7a2e42e9c7c9b215fb360dc314aa3"><td class="memItemLeft" align="right" valign="top"><a id="aa8f7a2e42e9c7c9b215fb360dc314aa3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resume</b> ()</td></tr>
<tr class="separator:aa8f7a2e42e9c7c9b215fb360dc314aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c297384fb3fb1e1aed3b698390cd9e"><td class="memItemLeft" align="right" valign="top"><a id="ac2c297384fb3fb1e1aed3b698390cd9e"></a>
esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><b>resume_return_errors</b> ()</td></tr>
<tr class="separator:ac2c297384fb3fb1e1aed3b698390cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a59e904b258a8e455461e4039b9efc7fb"><td class="memItemLeft" align="right" valign="top"><a id="a59e904b258a8e455461e4039b9efc7fb"></a>
esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><b>_attach_ms</b> (uint32_t arg)</td></tr>
<tr class="separator:a59e904b258a8e455461e4039b9efc7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a822d8b5b5f95f86e302e17ff53464161"><td class="memItemLeft" align="right" valign="top"><a id="a822d8b5b5f95f86e302e17ff53464161"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>_interval_ms</b></td></tr>
<tr class="separator:a822d8b5b5f95f86e302e17ff53464161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1abfdbd839ebab42e69090d71051481"><td class="memItemLeft" align="right" valign="top"><a id="ab1abfdbd839ebab42e69090d71051481"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>_repeat_count_requested</b> {1}</td></tr>
<tr class="separator:ab1abfdbd839ebab42e69090d71051481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2349bd3cc53de3c755cc022743c841b8"><td class="memItemLeft" align="right" valign="top"><a id="a2349bd3cc53de3c755cc022743c841b8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>_repeat_count</b> {0}</td></tr>
<tr class="separator:a2349bd3cc53de3c755cc022743c841b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68819e1dccf40c89a0a6a950cd1d012"><td class="memItemLeft" align="right" valign="top"><a id="aa68819e1dccf40c89a0a6a950cd1d012"></a>
callback_t&#160;</td><td class="memItemRight" valign="bottom"><b>_callback</b></td></tr>
<tr class="separator:aa68819e1dccf40c89a0a6a950cd1d012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0327788224f8815cdf3ad36546500"><td class="memItemLeft" align="right" valign="top"><a id="a0ee0327788224f8815cdf3ad36546500"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>_orig_arg</b> {0}</td></tr>
<tr class="separator:a0ee0327788224f8815cdf3ad36546500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad984bf2e11f7509fcae643a7de8ff4eb"><td class="memItemLeft" align="right" valign="top"><a id="ad984bf2e11f7509fcae643a7de8ff4eb"></a>
callback_with_arg_t&#160;</td><td class="memItemRight" valign="bottom"><b>_cb_lambda</b> {nullptr}</td></tr>
<tr class="separator:ad984bf2e11f7509fcae643a7de8ff4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730a1a865f761e51eaf298e8caa5003f"><td class="memItemLeft" align="right" valign="top"><a id="a730a1a865f761e51eaf298e8caa5003f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_first_tick_nodelay</b> {false}</td></tr>
<tr class="separator:a730a1a865f761e51eaf298e8caa5003f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Ticker timer derivative allowing for a fixed number of repeated calls. </p>
<p>This also allows unlimited on-demand restarting of the already attached callback without deleting the existing timer first.</p>
<p>Like for the original Ticker.h version, all callbacks are invoked from "esp_timer" task, which is a high-priority task. For this reason, the callbacks should only perform a minimum amount of work and refer to other tasks via message passing to do any blocking action. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab11322a4f50ffccc19cde0caf302b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11322a4f50ffccc19cde0caf302b221">&#9670;&nbsp;</a></span>attach_static_ms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TArg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t MultiTimer::attach_static_ms </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>total_repeat_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(type_identity_t&lt; TArg &gt;, uint32_t)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArg&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_tick_nodelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach a free function, static member function or a non-capturing lambda function to the timer. </p>
<p>This timer is created without activating it.</p><ul>
<li>It is activated by calling <a class="el" href="class_multi_timer.html#a2478d115c8db9b4c1e3013ebfe525c81">start()</a>.</li>
<li>It is stopped without detaching the callback by calling stop(), which also resets the number of repeats to its original value.</li>
<li>It can be paused by calling pause(), which does not reset the repeats.</li>
<li>After calling resume(), continues until total repeat count is reached.</li>
</ul>
<p>The callback can receive zero, one or two arguments:</p><ul>
<li>For no arguments, it is just called the preset number of times.</li>
<li>For one argument, this is a fixed value for all calls, typically the pointer to the object of a user class for accessing any member of it.</li>
<li>In case of two arguments, the second is an additional uint32_t value containing the current number of times the callback was called. (This wraps around after UINT32_MAX)</li>
</ul>
<p>The macros TICKER_MEMBER_CALL() and TICKER_MEMBER_CALL_WITH_COUNT() are a short-cut for calling non-static member functions from a calling class object by inserting a lambda in place of the member function name:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintFoo {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="class_multi_timer.html">MultiTimer</a> timer;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *foo_str = <span class="stringliteral">&quot;This is Foo Number: %d&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> print_foo(uint32_t i) {</div>
<div class="line">        printf(foo_str, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    PrintFoo(uint32_t millisecs, uint32_t reps) {</div>
<div class="line">        timer.<a class="code" href="class_multi_timer.html#ab11322a4f50ffccc19cde0caf302b221">attach_static_ms</a>(millisecs,</div>
<div class="line">                               reps,</div>
<div class="line">                               TICKER_MEMBER_CALL_WITH_COUNT(print_foo)</div>
<div class="line">                               );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">PrintFoo print_6x_foo{500, 6};</div>
<div class="line">print_6x_foo.timer.start();</div>
</div><!-- fragment --><p>==&gt; Please note: This software timer is only relatively accurate. That menas, for each repeat, the timer is stopped and started again immediately if the total number of repeats is not yet reached. This means that for multiple repeats, each small timing error will sum up to a larger value. If you need accurate timing for a large (or infinite) number of repeats, please use the Ticker class which features the periodic attach_ms() which has better long-term accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>Timer interval in milliseconds </td></tr>
    <tr><td class="paramname">total_repeat_count</td><td>Timer is stopped after this many repeats </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to register into this timer </td></tr>
    <tr><td class="paramname">arg</td><td>Numeric arg or pointer to object, e.g. calling class instance </td></tr>
    <tr><td class="paramname">first_tick_nodelay</td><td>If set to true, call callback immediately when the <a class="el" href="class_multi_timer.html#a2478d115c8db9b4c1e3013ebfe525c81">start()</a> function is invoked, the first tick counts as a normal repeat and is repeated until total repeat count is reached </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2478d115c8db9b4c1e3013ebfe525c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478d115c8db9b4c1e3013ebfe525c81">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultiTimer::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Without return value, we don't get this out of the lambda without another class member.. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="multi__timer_8hpp_source.html">multi_timer.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_multi_timer_html"><div class="ttname"><a href="class_multi_timer.html">MultiTimer</a></div><div class="ttdoc">Ticker timer derivative allowing for a fixed number of repeated calls.</div><div class="ttdef"><b>Definition:</b> multi_timer.hpp:34</div></div>
<div class="ttc" id="aclass_multi_timer_html_ab11322a4f50ffccc19cde0caf302b221"><div class="ttname"><a href="class_multi_timer.html#ab11322a4f50ffccc19cde0caf302b221">MultiTimer::attach_static_ms</a></div><div class="ttdeci">esp_err_t attach_static_ms(uint32_t milliseconds, uint32_t total_repeat_count, void(*callback)(type_identity_t&lt; TArg &gt;, uint32_t), TArg arg, bool first_tick_nodelay=false)</div><div class="ttdoc">Attach a free function, static member function or a non-capturing lambda function to the timer.</div><div class="ttdef"><b>Definition:</b> multi_timer.hpp:111</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
